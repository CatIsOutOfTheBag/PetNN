# Персептрон линейно разделимые классы
import matplotlib.pyplot as plt
import numpy as np

N=5 # по 5 точек на каждый класс
b=3

x1 = np.random.random(N) # случайные значения
x2 = x1 + [np.random.randint(10)/10 for i in range(N)] + b # эти же значения + шум, будут лежать ВЫШЕ прямой
C1 = [x1, x2] # пары - координаты точек (x1, x2) - класс 1

x1 = np.random.random(N) # случайные значения
x2 = x1 - [np.random.randint(10)/10 for i in range(N)] - 0.1 + b# эти же значения - шум, будут лежать НИЖЕ прямой
C2 = [x1, x2] # пары - координаты точек (x1, x2) - класс 2

f = [0+b,1+b] # прямая под 45 гр

w2 = 0.5
w3 = -b*w2
w = np.array([-w2, w2, w3]) # веса НС

# перебираем все образы для класса С2
for i in range(N):
    x = np.array([C1[0][i], C1[1][i], 1])
    y = np.dot(w, x) # вычисляем выходное значение y
    if y >= 0:
        print("Класс С1")
    else:
        print("Класс С2")
        
        
# отображаем точки класса С1 и С2 и разделяющую прямую
plt.scatter(C1[0][:], C1[1][:], s=10, c='red')
plt.scatter(C2[0][:], C2[1][:], s=10, c='blue')
plt.plot(f)
plt.grid(True)       
plt.show()

# Тут мы увидим идеальную картину.
# Но радоваться не стоит, на практике классы почти никогда линейно не разделяются
# Персептрон линейно неразделимые классы
import numpy as np

def act(x): # активационная функция
    return 0 if x<=0 else 1

def go(C): # НС
    x = np.array([C[0], C[1], 1]) # входные значения (0 или 1), биас
    w1 = [1,1,-1.5] # веса для первого нейрона (подходят к нейрону)
    w2 = [1,1,-0.5] # веса для второго нейрона
    w_hidden = np.array([w1,w2]) # объединяем веса в матрицу
    w_out = np.array([-1, 1, -0.5]) # определяем веса для выходного ненйрона
    
    summa = np.dot(w_hidden, x) # вычисляем сумму на каждом нейроне - произведение признаков на веса
    out = [act(x) for x in summa] # пропускаем эти суммы через ф-ию активации
    out.append(1) # добавляем 1
    out = np.array(out) # превращаем в вектор
    
    summa = np.dot(w_out, out) # домножаем на весовые коэф-ты выходного нейрона
    y = act(summa) # пропускаем через ф-ию активации
    return y # получаем выходное значение сети

C1 = [(1,0), (0,1)] 
C2 = [(0,0), (1,1)] 

print( go(C1[0]), go(C1[1]) ) # пропускаем сначала первый класс
print( go(C2[0]), go(C2[1]) ) # затем второй

# видим точки (1,0), (0,1) как 1,1 - первый класс
# видим точки (0,0), (1,1) как 0,0 - второй класс
# а вот тут можно радоваться. Персептрон неплохо справляется даже с линейно неразделимыми классами
